package codegen

import codegen.PropertyType.Companion.parse
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import kotlinx.serialization.json.*

val EMPTY_JSON_OBJECT = JsonObject(emptyMap())

private val JsonObject.required: List<String>
    get() = get("required")?.jsonArray?.map { it.jsonPrimitive.content } ?: emptyList()

fun createJsonSchema(id: String, json: JsonObject): FileSpec = FileSpec.builder(proto, id.schemaName)
    .indent("    ")
    .addJsonSchemaType(id, json)
    .addFileComment("DO NOT EDIT THIS FILE! This was generated by the `./gradlew :generateJetStreamClasses` task.`")
    .build()

fun FileSpec.Builder.addJsonSchemaType(id: String, json: JsonObject): FileSpec.Builder {
    val builder = TypeSpec.classBuilder(id.schemaName)
        .serializable()
        .addSerialName(id)

    if ("response" in id) {
        builder.addSuperinterface(ClassName(proto, "Response"))
    }

    when {
        /*  */
        "oneOf" in json -> {
            val nonError = json["oneOf"]
                ?.jsonArray
                ?.filterIsInstance<JsonObject>()
                ?.filterNot { it["properties"]?.jsonObject?.contains("error") ?: true }
                ?: error("unknown 'oneOf' type: $json")

            require(nonError.size == 1) {
                "bruh"
            }

            val obj = nonError.first()
            builder.addModifiers(KModifier.DATA)
            builder.addProperties(obj, obj["properties"]!!.jsonObject)
        }

        "allOf" in json -> {
            val allOf = json["allOf"]
                ?.jsonArray
                ?.filterIsInstance<JsonObject>()
                ?: error("unknown 'allOf' type: $json")

            builder.addModifiers(KModifier.DATA)
            for (obj in allOf) {
                require(obj.type.name == "object")
                builder.addProperties(obj, obj["properties"]?.jsonObject ?: EMPTY_JSON_OBJECT)
            }
        }

        /* direct properties */
        "properties" in json -> {
            builder.addModifiers(KModifier.DATA)
            builder.addProperties(json, json["properties"]!!.jsonObject)
        }
    }

    return addType(builder.build())
}

fun findOrCreateSpec(root: TypeSpec.Builder, name: String, property: JsonObject) {
    if (root.typeSpecs.any { it.name == name.schemaName }) {
        return
    }

    val spec = TypeSpec.classBuilder(name.schemaName)
        .addModifiers(KModifier.DATA)
        .addProperties(property, property["properties"]?.jsonObject ?: EMPTY_JSON_OBJECT)
        .serializable()

    val allOf = property["allOf"]?.jsonArray?.filterIsInstance<JsonObject>()
    if (allOf != null) for (member in allOf) {
        require(member.type.name == "object")
        spec.addProperties(member, member["properties"]?.jsonObject ?: EMPTY_JSON_OBJECT)
    }

    root.addType(spec.build())
}

fun guessType(schema: JsonObject, root: TypeSpec.Builder, name: String, property: JsonObject): TypeName {
    fun TypeName.nullable(): TypeName =
        copy(nullable = name !in schema.required || isNullable)

    if (name in domains) {
        return domains[name]!!.nullable()
    }

    val typeName: PropertyType = property.type
    if (typeName.name == "object") {
        when {
            "patternProperties" in property -> {
                val thing = property["patternProperties"]?.jsonObject?.values
                    ?.first()
                    ?: error("couldn't get pattern property shit.")

                return MAP.parameterizedBy(
                    STRING,
                    guessType(property, root, name.removeSuffix("s"), thing.jsonObject).copy(nullable = false)
                ).nullable()
            }

            "additionalProperties" in property -> {
                val value = property["additionalProperties"]
                if (value is JsonObject) return MAP.parameterizedBy(STRING, value.guessType())
            }
        }

        //
        findOrCreateSpec(root, name, property)
        return ClassName("", name.schemaName).nullable()
    }

    return property.guessType().nullable()
}

val JsonObject.type: PropertyType
    get() = get("type")?.parse() ?: PropertyType("object", emptyList())

fun JsonObject.findDefaultValue(name: String): CodeBlock {
    val default = get("default")?.jsonPrimitive?.contentOrNull
        ?: return CodeBlock.of("null")

    if (name in domains) {
        return CodeBlock.of("%L", domains[name]?.nestedClass(default.schemaName))
    }

    return CodeBlock.of("%L", default)
}

fun TypeSpec.Builder.addProperties(schema: JsonObject, properties: JsonObject): TypeSpec.Builder {
    val props = properties.mapValues { it.value.jsonObject }

    // create the primary constructor.
    val constructor = FunSpec.constructorBuilder()
    for ((name, property) in props) {
        val type = guessType(schema, this, name, property.jsonObject)

        //
        val parameter = ParameterSpec.builder(name.normalized, type)
        if (type.isNullable) {
            val default = property.findDefaultValue(name)
            parameter.defaultValue(default)
        }

        constructor.addParameter(parameter.build())
    }

    primaryConstructor(constructor.build())

    // create properties and shit.
    for ((name, property) in props.mapValues { it.value.jsonObject }) {
        val spec = PropertySpec.builder(name.normalized, guessType(schema, this, name, property))
            .addKdoc(property["description"]?.jsonPrimitive?.contentOrNull ?: "")
            .initializer(name.normalized)

        if (name != name.normalized) {
            spec.addSerialName(name)
        }

        addProperty(spec.build())
    }

    return this
}
