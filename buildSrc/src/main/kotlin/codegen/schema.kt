package codegen

import codegen.PropertyType.Companion.parse
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import json.schema.JsonSchema
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonPrimitive

val EMPTY_JSON_OBJECT = JsonObject(emptyMap())

private val JsonObject.required: List<String>
    get() = get("required")?.jsonArray?.map { it.jsonPrimitive.content } ?: emptyList()

fun JsonSchema.createFileSpec(id: String) = FileSpec(proto pk id.schemaName) {
    val mis = MoreInformativeSchema(this, null, this@createFileSpec, id, ANY)

    indent("    ")
    addFileComment("DO NOT EDIT THIS FILE! This was generated by the `./gradlew :generateJetStreamClasses` task.`")
    addType(mis.createTypeSpec())
}

data class MoreInformativeSchema(
    val fileBuilder: FileSpec.Builder,
    val typeBuilder: TypeSpec.Builder? = null,
    val schema: JsonSchema,
    val id: String,
    val type: TypeName,
    var docs: String = schema.description,
    val required: Boolean = true,
) {
    fun copyWithSchema(schema: JsonSchema, type: TypeName? = null) = copy(
        schema = schema,
        docs = schema.description,
        type = type ?: this.type
    )

    fun copyAsParameter(schema: JsonSchema, type: TypeName?, name: String, root: JsonSchema) = copy(
        schema = schema,
        docs = schema.description,
        type = type ?: this.type,
        required = name in root.required
    )
}

fun MoreInformativeSchema.createTypeSpec(root: MoreInformativeSchema? = null): TypeSpec = KClass(id.schemaName) {
    serializable()
    addKdoc(docs)
    if (root == null) addSerialName(id)

    fun Map<String, JsonSchema>.convert(root: JsonSchema = schema) = mapValues {
        copyAsParameter(it.value, it.value.guessType(schema, it.key), it.key, root)
    }

    val props = schema.properties
        .convert()
        .toMutableMap()

    applyToProperties(root, this, props)

    if (schema.allOf.isNotEmpty()) {
        for (entry in schema.allOf) {
            val properties = entry.properties
                .convert(entry)
                .toMutableMap()

            copyWithSchema(entry).applyToProperties(this@createTypeSpec, this, properties)
            props.putAll(properties)
        }
    } else if (schema.oneOf.isNotEmpty()) {
        /* nats.kt specific -- start */
        val nonError = schema.oneOf
            .filterNot { "error" in it.properties }
            .first()

        val properties = nonError.properties
            .convert(nonError)
            .toMutableMap()

        copyWithSchema(nonError).applyToProperties(this@createTypeSpec, this, properties)
        props.putAll(properties)
        /* nats.kt specific -- end */
    }

    if (props.isNotEmpty()) {
        modifiers += KModifier.DATA
    }

    primaryConstructor(createPrimaryConstructor(props))
    addProperties(props.map { (n, s) -> s.createProperty(this@createTypeSpec, n) })
}

fun MoreInformativeSchema.applyToProperties(
    root: MoreInformativeSchema? = null,
    typeBuilder: TypeSpec.Builder,
    properties: MutableMap<String, MoreInformativeSchema>,
) {
    fun getNewType(name: String, property: MoreInformativeSchema, type: PropertyType): TypeName? {
        val toAdd = root?.typeBuilder ?: typeBuilder
        return domains[name] ?: when (type.name) {
            "string" -> if (property.schema.isEnum()) {

                val enumBuilder = TypeSpec.enumBuilder(name.schemaName)
                    .serializable()
                    .addKdoc(property.docs)

                for (member in property.schema.enum) {
                    val memberType = TypeSpec.anonymousClassBuilder()
                        .addSerialName(member.content)
                        .build()

                    enumBuilder.addEnumConstant(member.content.schemaName, memberType)
                }

                /* build the enum and add it to this type */
                toAdd.addType(enumBuilder.build())

                ClassName("", name.schemaName)
            } else {
                null
            }

            "array" -> {
                val item = when (property.schema.items) {
                    //
                    is JsonSchema.Items.Multiple -> error("Cannot Accept Multiple Item Types")

                    //
                    is JsonSchema.Items.Single -> when (property.schema.items.value) {
                        //
                        is JsonSchema.OrBoolean.Bool -> error("idfk what you want me to do.")

                        //
                        is JsonSchema.OrBoolean.Value -> {
                            val itemType = property.schema.items.value.value
                            property.docs = itemType.description

                            getNewType(name, property.copy(schema = itemType), itemType.type?.parse() ?: return null)
                                ?: itemType.guessType()
                        }
                    }

                    else -> error("Expected 'items' to be non-null for array type.")
                }

                LIST.parameterizedBy(item)
            }

            "object" -> {
                val objectType = property.copy(id = name).createTypeSpec(this)
                toAdd.addType(objectType)
                ClassName("", objectType.name ?: "")
            }

            else -> null
        }
    }

    for ((name, property) in properties) {
        val type = property.schema.type?.parse()
            ?.let { getNewType(name, property, it) }
            ?: continue

        if ("create" in id && name in listOf("config", "state")) {
            println("$name\n\t- $property\n\t- $this")
        }

        val required = name in schema.required
        properties[name] = property.copy(type = if (!required) type.asNullable() else type, required = required)
    }
}

fun JsonSchema.isEnum() = type?.parse()?.name == "string" && enum.isNotEmpty()

fun MoreInformativeSchema.createPrimaryConstructor(properties: Map<String, MoreInformativeSchema>): FunSpec {
    return FunSpec.constructorBuilder()
        .addParameters(properties.map { (n, s) -> s.createParameter(this, n) })
        .build()
}

fun MoreInformativeSchema.guessReturnValue(root: MoreInformativeSchema, name: String): CodeBlock? {
    val code: String = if (schema.default != null) {
        val value = schema.default.jsonPrimitive
        if (schema.isEnum()) {
            val enumName = domains[name]?.simpleName ?: name.schemaName
            "$enumName.${value.content.schemaName}"
        } else if (value.isString && !value.content.all { it.isDigit() }) {
            value.toString()
        } else {
            value.content
        }
    } else if (!root.required) {
        "null"
    } else {
        return null
    }

    return CodeBlock.of("%L", code)
}

fun JsonSchema.guessType(root: JsonSchema, name: String): TypeName {
    val type = guessType()
    return if (name !in root.required) type.asNullable() else type
}

fun MoreInformativeSchema.createParameter(root: MoreInformativeSchema, name: String): ParameterSpec {
    return ParameterSpec.builder(name.normalized, type)
        .defaultValue(guessReturnValue(root, name))
        .build()
}

fun MoreInformativeSchema.createProperty(root: MoreInformativeSchema, name: String): PropertySpec {
    val builder = PropertySpec.builder(name.normalized, type)
    if (name.normalized != name) {
        builder.addSerialName(name)
    }

    return builder
        .addKdoc(docs)
        .initializer(name.normalized)
        .build()
}
