// DO NOT EDIT THIS FILE! This was generated by the `./gradlew :generateJetStreamClasses` task.`
package nats.jetstream.protocol

import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.ULong
import kotlin.collections.List
import kotlin.collections.Map
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonObject
import nats.jetstream.protocol.domain.StreamDiscardType
import nats.jetstream.protocol.domain.StreamRetentionPolicy
import nats.jetstream.protocol.domain.StreamStorageType

@Serializable
@SerialName("io.nats.jetstream.api.v1.stream_update_response")
public data class StreamUpdateResponse(
    /**
     * The active configuration for the Stream
     */
    public val config: Config,
    /**
     * Detail about the current State of the Stream
     */
    public val state: State,
    /**
     * Timestamp when the stream was created
     */
    public val created: String,
    public val cluster: Cluster? = null,
    /**
     * Information about an upstream stream source in a mirror
     */
    public val mirror: Mirror? = null,
    /**
     * Streams being sourced into this Stream
     */
    public val sources: List<JsonObject>? = null,
    /**
     * List of mirrors sorted by priority
     */
    public val alternates: List<JsonObject>? = null,
) : Response {
    @Serializable
    public data class Config(
        /**
         * A unique name for the Stream, empty for Stream Templates.
         */
        public val name: String? = null,
        /**
         * A short description of the purpose of this stream
         */
        public val description: String? = null,
        /**
         * A list of subjects to consume, supports wildcards. Must be empty when a mirror is
         * configured. May be empty when sources are configured.
         */
        public val subjects: List<String>? = null,
        /**
         * How messages are retained in the Stream, once this is exceeded old messages are removed.
         */
        public val retention: StreamRetentionPolicy,
        /**
         * How many Consumers can be defined for a given Stream. -1 for unlimited.
         */
        @SerialName("max_consumers")
        public val maxConsumers: Long,
        /**
         * How many messages may be in a Stream, oldest messages will be removed if the Stream
         * exceeds this size. -1 for unlimited.
         */
        @SerialName("max_msgs")
        public val maxMsgs: Long,
        /**
         * For wildcard streams ensure that for every unique subject this many messages are kept - a
         * per subject retention limit
         */
        @SerialName("max_msgs_per_subject")
        public val maxMsgsPerSubject: Long? = -1,
        /**
         * How big the Stream may be, when the combined stream size exceeds this old messages are
         * removed. -1 for unlimited.
         */
        @SerialName("max_bytes")
        public val maxBytes: Long,
        /**
         * Maximum age of any message in the stream, expressed in nanoseconds. 0 for unlimited.
         */
        @SerialName("max_age")
        public val maxAge: Long,
        /**
         * The largest message that will be accepted by the Stream. -1 for unlimited.
         */
        @SerialName("max_msg_size")
        public val maxMsgSize: Int? = -1,
        /**
         * The storage backend to use for the Stream.
         */
        public val storage: StreamStorageType,
        /**
         * How many replicas to keep for each message.
         */
        @SerialName("num_replicas")
        public val numReplicas: Long,
        /**
         * Disables acknowledging messages that are received by the Stream.
         */
        @SerialName("no_ack")
        public val noAck: Boolean? = false,
        /**
         * When the Stream is managed by a Stream Template this identifies the template that manages
         * the Stream.
         */
        @SerialName("template_owner")
        public val templateOwner: String? = null,
        /**
         * When a Stream reach it's limits either old messages are deleted or new ones are denied
         */
        public val discard: StreamDiscardType? =
                nats.jetstream.protocol.domain.StreamDiscardType.Old,
        /**
         * The time window to track duplicate messages for, expressed in nanoseconds. 0 for default
         */
        @SerialName("duplicate_window")
        public val duplicateWindow: Long? = 0,
        /**
         * Placement directives to consider when placing replicas of this stream, random placement
         * when unset
         */
        public val placement: Placement? = null,
        /**
         * Maintains a 1:1 mirror of another stream with name matching this property.  When a mirror
         * is configured subjects and sources must be empty.
         */
        public val mirror: Mirror? = null,
        /**
         * List of Stream names to replicate into this Stream
         */
        public val sources: List<JsonObject>? = null,
        /**
         * Sealed streams do not allow messages to be deleted via limits or API, sealed streams can
         * not be unsealed via configuration update. Can only be set on already created streams via the
         * Update API
         */
        public val `sealed`: Boolean? = false,
        /**
         * Restricts the ability to delete messages from a stream via the API. Cannot be changed
         * once set to true
         */
        @SerialName("deny_delete")
        public val denyDelete: Boolean? = false,
        /**
         * Restricts the ability to purge messages from a stream via the API. Cannot be change once
         * set to true
         */
        @SerialName("deny_purge")
        public val denyPurge: Boolean? = false,
        /**
         * Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject
         * in a stream, with a single new message
         */
        @SerialName("allow_rollup_hdrs")
        public val allowRollupHdrs: Boolean? = false,
        /**
         * Allow higher performance, direct access to get individual messages
         */
        @SerialName("allow_direct")
        public val allowDirect: Boolean? = false,
        /**
         * Allow higher performance, direct access for mirrors as well
         */
        @SerialName("mirror_direct")
        public val mirrorDirect: Boolean? = false,
        /**
         * Rules for republishing messages from a stream with subject mapping onto new subjects for
         * partitioning and more
         */
        public val republish: Republish? = null,
        /**
         * When discard policy is new and the stream is one with max messages per subject set, this
         * will apply the new behavior to every subject. Essentially turning discard new from maximum
         * number of subjects into maximum number of messages in a subject.
         */
        @SerialName("discard_new_per_subject")
        public val discardNewPerSubject: Boolean? = false,
    ) {
        @Serializable
        public data class Placement(
            /**
             * The desired cluster name to place the stream
             */
            public val cluster: String,
            /**
             * Tags required on servers hosting this stream
             */
            public val tags: List<String>? = null,
        )

        @Serializable
        public data class Mirror(
            /**
             * Stream name
             */
            public val name: String,
            /**
             * Sequence to start replicating from
             */
            @SerialName("opt_start_seq")
            public val optStartSeq: ULong? = null,
            /**
             * Time stamp to start replicating from
             */
            @SerialName("opt_start_time")
            public val optStartTime: String? = null,
            /**
             * Replicate only a subset of messages based on filter
             */
            @SerialName("filter_subject")
            public val filterSubject: String? = null,
            /**
             * Configuration referencing a stream source in another account or JetStream domain
             */
            public val `external`: External? = null,
        ) {
            @Serializable
            public data class External(
                /**
                 * The subject prefix that imports the other account/domain $JS.API.CONSUMER.>
                 * subjects
                 */
                public val api: String,
                /**
                 * The delivery subject to use for the push consumer
                 */
                public val deliver: String? = null,
            )
        }

        @Serializable
        public data class Republish(
            /**
             * The source subject to republish
             */
            public val src: String,
            /**
             * The destination to publish to
             */
            public val dest: String,
            /**
             * Only send message headers, no bodies
             */
            @SerialName("headers_only")
            public val headersOnly: Boolean? = false,
        )
    }

    @Serializable
    public data class State(
        /**
         * Number of messages stored in the Stream
         */
        public val messages: ULong,
        /**
         * Combined size of all messages in the Stream
         */
        public val bytes: ULong,
        /**
         * Sequence number of the first message in the Stream
         */
        @SerialName("first_seq")
        public val firstSeq: ULong,
        /**
         * The timestamp of the first message in the Stream
         */
        @SerialName("first_ts")
        public val firstTs: String? = null,
        /**
         * Sequence number of the last message in the Stream
         */
        @SerialName("last_seq")
        public val lastSeq: ULong,
        /**
         * The timestamp of the last message in the Stream
         */
        @SerialName("last_ts")
        public val lastTs: String? = null,
        /**
         * IDs of messages that were deleted using the Message Delete API or Interest based streams
         * removing messages out of order
         */
        public val deleted: List<ULong>? = null,
        /**
         * Subjects and their message counts when a subjects_filter was set
         */
        public val subjects: Map<String, ULong>,
        /**
         * The number of unique subjects held in the stream
         */
        @SerialName("num_subjects")
        public val numSubjects: Long? = null,
        /**
         * The number of deleted messages
         */
        @SerialName("num_deleted")
        public val numDeleted: Long? = null,
        /**
         * Records messages that were damaged and unrecoverable
         */
        public val lost: Lost? = null,
        /**
         * Number of Consumers attached to the Stream
         */
        @SerialName("consumer_count")
        public val consumerCount: Long,
    ) {
        @Serializable
        public data class Lost(
            /**
             * The messages that were lost
             */
            public val msgs: List<ULong>? = null,
            /**
             * The number of bytes that were lost
             */
            public val bytes: ULong? = null,
        )
    }

    @Serializable
    public data class Cluster(
        /**
         * The cluster name
         */
        public val name: String? = null,
        /**
         * The server name of the RAFT leader
         */
        public val leader: String? = null,
        /**
         * The members of the RAFT cluster
         */
        public val replicas: List<JsonObject>? = null,
    )

    @Serializable
    public data class Mirror(
        /**
         * The name of the Stream being replicated
         */
        public val name: String,
        /**
         * How many messages behind the mirror operation is
         */
        public val lag: ULong,
        /**
         * When last the mirror had activity, in nanoseconds. Value will be -1 when there has been
         * no activity.
         */
        public val active: Long,
        /**
         * Configuration referencing a stream source in another account or JetStream domain
         */
        public val `external`: External? = null,
        public val error: Error? = null,
    ) {
        @Serializable
        public data class External(
            /**
             * The subject prefix that imports the other account/domain $JS.API.CONSUMER.> subjects
             */
            public val api: String,
            /**
             * The delivery subject to use for the push consumer
             */
            public val deliver: String? = null,
        )

        @Serializable
        public data class Error(
            /**
             * HTTP like error code in the 300 to 500 range
             */
            public val code: Int,
            /**
             * A human friendly description of the error
             */
            public val description: String? = null,
            /**
             * The NATS error code unique to each kind of error
             */
            @SerialName("err_code")
            public val errCode: Int? = null,
        )
    }
}
