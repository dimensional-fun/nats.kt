// DO NOT EDIT THIS FILE! This was generated by the `./gradlew :generateJetStreamClasses` task.`
package nats.jetstream.protocol

import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.ULong
import kotlin.collections.List
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import nats.jetstream.protocol.domain.ConsumerAckPolicy
import nats.jetstream.protocol.domain.ConsumerReplayPolicy

@Serializable
@SerialName("io.nats.jetstream.api.v1.consumer_create_request")
public data class ConsumerCreateRequest(
    /**
     * The name of the stream to create the consumer in
     */
    @SerialName("stream_name")
    public val streamName: String,
    /**
     * The consumer configuration
     */
    public val config: Config,
) {
    @Serializable
    public data class Config() {
        /**
         * A unique name for a durable consumer
         */
        @SerialName("durable_name")
        public val durableName: String? = durableName

        /**
         * A unique name for a consumer
         */
        public val name: String? = name

        /**
         * A short description of the purpose of this consumer
         */
        public val description: String? = description

        @SerialName("deliver_subject")
        public val deliverSubject: String? = deliverSubject

        @SerialName("ack_policy")
        public val ackPolicy: ConsumerAckPolicy = ackPolicy

        /**
         * How long (in nanoseconds) to allow messages to remain un-acknowledged before attempting
         * redelivery
         */
        @SerialName("ack_wait")
        public val ackWait: Long? = ackWait

        /**
         * The number of times a message will be redelivered to consumers if not acknowledged in
         * time
         */
        @SerialName("max_deliver")
        public val maxDeliver: Long? = maxDeliver

        @SerialName("filter_subject")
        public val filterSubject: String? = filterSubject

        @SerialName("replay_policy")
        public val replayPolicy: ConsumerReplayPolicy = replayPolicy

        @SerialName("sample_freq")
        public val sampleFreq: String? = sampleFreq

        /**
         * The rate at which messages will be delivered to clients, expressed in bit per second
         */
        @SerialName("rate_limit_bps")
        public val rateLimitBps: ULong? = rateLimitBps

        /**
         * The maximum number of messages without acknowledgement that can be outstanding, once this
         * limit is reached message delivery will be suspended
         */
        @SerialName("max_ack_pending")
        public val maxAckPending: Long? = maxAckPending

        /**
         * If the Consumer is idle for more than this many nano seconds a empty message with Status
         * header 100 will be sent indicating the consumer is still alive
         */
        @SerialName("idle_heartbeat")
        public val idleHeartbeat: Long? = idleHeartbeat

        /**
         * For push consumers this will regularly send an empty mess with Status header 100 and a
         * reply subject, consumers must reply to these messages to control the rate of message
         * delivery
         */
        @SerialName("flow_control")
        public val flowControl: Boolean? = flowControl

        /**
         * The number of pulls that can be outstanding on a pull consumer, pulls received after this
         * is reached are ignored
         */
        @SerialName("max_waiting")
        public val maxWaiting: Long? = maxWaiting

        /**
         * Creates a special consumer that does not touch the Raft layers, not for general use by
         * clients, internal use only
         */
        public val direct: Boolean? = direct

        /**
         * Delivers only the headers of messages in the stream and not the bodies. Additionally adds
         * Nats-Msg-Size header to indicate the size of the removed payload
         */
        @SerialName("headers_only")
        public val headersOnly: Boolean? = headersOnly

        /**
         * The largest batch property that may be specified when doing a pull on a Pull Consumer
         */
        @SerialName("max_batch")
        public val maxBatch: Int? = maxBatch

        /**
         * The maximum expires value that may be set when doing a pull on a Pull Consumer
         */
        @SerialName("max_expires")
        public val maxExpires: Long? = maxExpires

        /**
         * The maximum bytes value that maybe set when dong a pull on a Pull Consumer
         */
        @SerialName("max_bytes")
        public val maxBytes: Long? = maxBytes

        /**
         * Duration that instructs the server to cleanup ephemeral consumers that are inactive for
         * that long
         */
        @SerialName("inactive_threshold")
        public val inactiveThreshold: Long? = inactiveThreshold

        /**
         * List of durations in Go format that represents a retry time scale for NaK'd messages
         */
        public val backoff: List<Long>? = backoff

        /**
         * When set do not inherit the replica count from the stream but specifically set it to this
         * amount
         */
        @SerialName("num_replicas")
        public val numReplicas: Long? = numReplicas

        /**
         * Force the consumer state to be kept in memory rather than inherit the setting from the
         * stream
         */
        @SerialName("mem_storage")
        public val memStorage: Boolean? = memStorage
    }
}
