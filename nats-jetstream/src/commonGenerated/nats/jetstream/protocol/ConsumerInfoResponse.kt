// DO NOT EDIT THIS FILE! This was generated by the `./gradlew :generateJetStreamClasses` task.`
package nats.jetstream.protocol

import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.ULong
import kotlin.collections.List
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonObject
import nats.jetstream.protocol.domain.ConsumerAckPolicy
import nats.jetstream.protocol.domain.ConsumerReplayPolicy

@Serializable
@SerialName("io.nats.jetstream.api.v1.consumer_info_response")
public data class ConsumerInfoResponse(
    /**
     * The Stream the consumer belongs to
     */
    @SerialName("stream_name")
    public val streamName: String,
    /**
     * A unique name for the consumer, either machine generated or the durable name
     */
    public val name: String,
    public val config: Config,
    /**
     * The time the Consumer was created
     */
    public val created: String,
    /**
     * The last message delivered from this Consumer
     */
    public val delivered: Delivered,
    /**
     * The highest contiguous acknowledged message
     */
    @SerialName("ack_floor")
    public val ackFloor: AckFloor,
    /**
     * The number of messages pending acknowledgement
     */
    @SerialName("num_ack_pending")
    public val numAckPending: Long,
    /**
     * The number of redeliveries that have been performed
     */
    @SerialName("num_redelivered")
    public val numRedelivered: Long,
    /**
     * The number of pull consumers waiting for messages
     */
    @SerialName("num_waiting")
    public val numWaiting: Long,
    /**
     * The number of messages left unconsumed in this Consumer
     */
    @SerialName("num_pending")
    public val numPending: ULong,
    public val cluster: Cluster? = null,
    /**
     * Indicates if any client is connected and receiving messages from a push consumer
     */
    @SerialName("push_bound")
    public val pushBound: Boolean? = null,
) : Response {
    @Serializable
    public data class Config() {
        /**
         * A unique name for a durable consumer
         */
        @SerialName("durable_name")
        public val durableName: String? = durableName

        /**
         * A unique name for a consumer
         */
        public val name: String? = name

        /**
         * A short description of the purpose of this consumer
         */
        public val description: String? = description

        @SerialName("deliver_subject")
        public val deliverSubject: String? = deliverSubject

        @SerialName("ack_policy")
        public val ackPolicy: ConsumerAckPolicy = ackPolicy

        /**
         * How long (in nanoseconds) to allow messages to remain un-acknowledged before attempting
         * redelivery
         */
        @SerialName("ack_wait")
        public val ackWait: Long? = ackWait

        /**
         * The number of times a message will be redelivered to consumers if not acknowledged in
         * time
         */
        @SerialName("max_deliver")
        public val maxDeliver: Long? = maxDeliver

        @SerialName("filter_subject")
        public val filterSubject: String? = filterSubject

        @SerialName("replay_policy")
        public val replayPolicy: ConsumerReplayPolicy = replayPolicy

        @SerialName("sample_freq")
        public val sampleFreq: String? = sampleFreq

        /**
         * The rate at which messages will be delivered to clients, expressed in bit per second
         */
        @SerialName("rate_limit_bps")
        public val rateLimitBps: ULong? = rateLimitBps

        /**
         * The maximum number of messages without acknowledgement that can be outstanding, once this
         * limit is reached message delivery will be suspended
         */
        @SerialName("max_ack_pending")
        public val maxAckPending: Long? = maxAckPending

        /**
         * If the Consumer is idle for more than this many nano seconds a empty message with Status
         * header 100 will be sent indicating the consumer is still alive
         */
        @SerialName("idle_heartbeat")
        public val idleHeartbeat: Long? = idleHeartbeat

        /**
         * For push consumers this will regularly send an empty mess with Status header 100 and a
         * reply subject, consumers must reply to these messages to control the rate of message
         * delivery
         */
        @SerialName("flow_control")
        public val flowControl: Boolean? = flowControl

        /**
         * The number of pulls that can be outstanding on a pull consumer, pulls received after this
         * is reached are ignored
         */
        @SerialName("max_waiting")
        public val maxWaiting: Long? = maxWaiting

        /**
         * Creates a special consumer that does not touch the Raft layers, not for general use by
         * clients, internal use only
         */
        public val direct: Boolean? = direct

        /**
         * Delivers only the headers of messages in the stream and not the bodies. Additionally adds
         * Nats-Msg-Size header to indicate the size of the removed payload
         */
        @SerialName("headers_only")
        public val headersOnly: Boolean? = headersOnly

        /**
         * The largest batch property that may be specified when doing a pull on a Pull Consumer
         */
        @SerialName("max_batch")
        public val maxBatch: Int? = maxBatch

        /**
         * The maximum expires value that may be set when doing a pull on a Pull Consumer
         */
        @SerialName("max_expires")
        public val maxExpires: Long? = maxExpires

        /**
         * The maximum bytes value that maybe set when dong a pull on a Pull Consumer
         */
        @SerialName("max_bytes")
        public val maxBytes: Long? = maxBytes

        /**
         * Duration that instructs the server to cleanup ephemeral consumers that are inactive for
         * that long
         */
        @SerialName("inactive_threshold")
        public val inactiveThreshold: Long? = inactiveThreshold

        /**
         * List of durations in Go format that represents a retry time scale for NaK'd messages
         */
        public val backoff: List<Long>? = backoff

        /**
         * When set do not inherit the replica count from the stream but specifically set it to this
         * amount
         */
        @SerialName("num_replicas")
        public val numReplicas: Long? = numReplicas

        /**
         * Force the consumer state to be kept in memory rather than inherit the setting from the
         * stream
         */
        @SerialName("mem_storage")
        public val memStorage: Boolean? = memStorage
    }

    @Serializable
    public data class Delivered(
        /**
         * The sequence number of the Consumer
         */
        @SerialName("consumer_seq")
        public val consumerSeq: ULong,
        /**
         * The sequence number of the Stream
         */
        @SerialName("stream_seq")
        public val streamSeq: ULong,
        /**
         * The last time a message was delivered or acknowledged (for ack_floor)
         */
        @SerialName("last_active")
        public val lastActive: String? = null,
    )

    @Serializable
    public data class AckFloor(
        /**
         * The sequence number of the Consumer
         */
        @SerialName("consumer_seq")
        public val consumerSeq: ULong,
        /**
         * The sequence number of the Stream
         */
        @SerialName("stream_seq")
        public val streamSeq: ULong,
        /**
         * The last time a message was delivered or acknowledged (for ack_floor)
         */
        @SerialName("last_active")
        public val lastActive: String? = null,
    )

    @Serializable
    public data class Cluster(
        /**
         * The cluster name
         */
        public val name: String? = null,
        /**
         * The server name of the RAFT leader
         */
        public val leader: String? = null,
        /**
         * The members of the RAFT cluster
         */
        public val replicas: List<JsonObject>? = null,
    )
}
