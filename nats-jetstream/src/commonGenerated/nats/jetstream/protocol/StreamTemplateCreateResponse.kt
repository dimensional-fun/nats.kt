// DO NOT EDIT THIS FILE! This was generated by the `./gradlew :generateJetStreamClasses` task.`
package nats.jetstream.protocol

import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.ULong
import kotlin.collections.List
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonObject
import nats.jetstream.protocol.domain.StreamDiscardType
import nats.jetstream.protocol.domain.StreamRetentionPolicy
import nats.jetstream.protocol.domain.StreamStorageType

@Serializable
@SerialName("io.nats.jetstream.api.v1.stream_template_create_response")
public data class StreamTemplateCreateResponse(
    public val config: Config,
    /**
     * List of Streams managed by this Template
     */
    public val streams: List<String>,
) : Response {
    @Serializable
    public data class Config(
        /**
         * A unique name for the Template
         */
        public val name: String,
        /**
         * The template configuration to create Streams with
         */
        public val config: Config,
        /**
         * The maximum number of streams to allow using this Template
         */
        @SerialName("max_streams")
        public val maxStreams: Int,
    ) {
        @Serializable
        public data class Config(
            /**
             * A unique name for the Stream, empty for Stream Templates.
             */
            public val name: String? = null,
            /**
             * A short description of the purpose of this stream
             */
            public val description: String? = null,
            /**
             * A list of subjects to consume, supports wildcards. Must be empty when a mirror is
             * configured. May be empty when sources are configured.
             */
            public val subjects: List<String>? = null,
            /**
             * How messages are retained in the Stream, once this is exceeded old messages are
             * removed.
             */
            public val retention: StreamRetentionPolicy,
            /**
             * How many Consumers can be defined for a given Stream. -1 for unlimited.
             */
            @SerialName("max_consumers")
            public val maxConsumers: Long,
            /**
             * How many messages may be in a Stream, oldest messages will be removed if the Stream
             * exceeds this size. -1 for unlimited.
             */
            @SerialName("max_msgs")
            public val maxMsgs: Long,
            /**
             * For wildcard streams ensure that for every unique subject this many messages are
             * kept - a per subject retention limit
             */
            @SerialName("max_msgs_per_subject")
            public val maxMsgsPerSubject: Long? = -1,
            /**
             * How big the Stream may be, when the combined stream size exceeds this old messages
             * are removed. -1 for unlimited.
             */
            @SerialName("max_bytes")
            public val maxBytes: Long,
            /**
             * Maximum age of any message in the stream, expressed in nanoseconds. 0 for unlimited.
             */
            @SerialName("max_age")
            public val maxAge: Long,
            /**
             * The largest message that will be accepted by the Stream. -1 for unlimited.
             */
            @SerialName("max_msg_size")
            public val maxMsgSize: Int? = -1,
            /**
             * The storage backend to use for the Stream.
             */
            public val storage: StreamStorageType,
            /**
             * How many replicas to keep for each message.
             */
            @SerialName("num_replicas")
            public val numReplicas: Long,
            /**
             * Disables acknowledging messages that are received by the Stream.
             */
            @SerialName("no_ack")
            public val noAck: Boolean? = false,
            /**
             * When the Stream is managed by a Stream Template this identifies the template that
             * manages the Stream.
             */
            @SerialName("template_owner")
            public val templateOwner: String? = null,
            /**
             * When a Stream reach it's limits either old messages are deleted or new ones are
             * denied
             */
            public val discard: StreamDiscardType? =
                    nats.jetstream.protocol.domain.StreamDiscardType.Old,
            /**
             * The time window to track duplicate messages for, expressed in nanoseconds. 0 for
             * default
             */
            @SerialName("duplicate_window")
            public val duplicateWindow: Long? = 0,
            /**
             * Placement directives to consider when placing replicas of this stream, random
             * placement when unset
             */
            public val placement: Placement? = null,
            /**
             * Maintains a 1:1 mirror of another stream with name matching this property.  When a
             * mirror is configured subjects and sources must be empty.
             */
            public val mirror: Mirror? = null,
            /**
             * List of Stream names to replicate into this Stream
             */
            public val sources: List<JsonObject>? = null,
            /**
             * Sealed streams do not allow messages to be deleted via limits or API, sealed streams
             * can not be unsealed via configuration update. Can only be set on already created streams
             * via the Update API
             */
            public val `sealed`: Boolean? = false,
            /**
             * Restricts the ability to delete messages from a stream via the API. Cannot be changed
             * once set to true
             */
            @SerialName("deny_delete")
            public val denyDelete: Boolean? = false,
            /**
             * Restricts the ability to purge messages from a stream via the API. Cannot be change
             * once set to true
             */
            @SerialName("deny_purge")
            public val denyPurge: Boolean? = false,
            /**
             * Allows the use of the Nats-Rollup header to replace all contents of a stream, or
             * subject in a stream, with a single new message
             */
            @SerialName("allow_rollup_hdrs")
            public val allowRollupHdrs: Boolean? = false,
            /**
             * Allow higher performance, direct access to get individual messages
             */
            @SerialName("allow_direct")
            public val allowDirect: Boolean? = false,
            /**
             * Allow higher performance, direct access for mirrors as well
             */
            @SerialName("mirror_direct")
            public val mirrorDirect: Boolean? = false,
            /**
             * Rules for republishing messages from a stream with subject mapping onto new subjects
             * for partitioning and more
             */
            public val republish: Republish? = null,
            /**
             * When discard policy is new and the stream is one with max messages per subject set,
             * this will apply the new behavior to every subject. Essentially turning discard new from
             * maximum number of subjects into maximum number of messages in a subject.
             */
            @SerialName("discard_new_per_subject")
            public val discardNewPerSubject: Boolean? = false,
        ) {
            @Serializable
            public data class Placement(
                /**
                 * The desired cluster name to place the stream
                 */
                public val cluster: String,
                /**
                 * Tags required on servers hosting this stream
                 */
                public val tags: List<String>? = null,
            )

            @Serializable
            public data class Mirror(
                /**
                 * Stream name
                 */
                public val name: String,
                /**
                 * Sequence to start replicating from
                 */
                @SerialName("opt_start_seq")
                public val optStartSeq: ULong? = null,
                /**
                 * Time stamp to start replicating from
                 */
                @SerialName("opt_start_time")
                public val optStartTime: String? = null,
                /**
                 * Replicate only a subset of messages based on filter
                 */
                @SerialName("filter_subject")
                public val filterSubject: String? = null,
                /**
                 * Configuration referencing a stream source in another account or JetStream domain
                 */
                public val `external`: External? = null,
            ) {
                @Serializable
                public data class External(
                    /**
                     * The subject prefix that imports the other account/domain $JS.API.CONSUMER.>
                     * subjects
                     */
                    public val api: String,
                    /**
                     * The delivery subject to use for the push consumer
                     */
                    public val deliver: String? = null,
                )
            }

            @Serializable
            public data class Republish(
                /**
                 * The source subject to republish
                 */
                public val src: String,
                /**
                 * The destination to publish to
                 */
                public val dest: String,
                /**
                 * Only send message headers, no bodies
                 */
                @SerialName("headers_only")
                public val headersOnly: Boolean? = false,
            )
        }
    }
}
